package co.blocke.scalabars

import fastparse._, ScalaWhitespace._

case class HandlebarsParser() {

  private def template[_: P] = P(renderable.repX)

  private def renderable[_: P]: P[Renderable] = P(strChars | comment | dynammicPartial | partial | block | inverted | !tryCloseBlock ~ variable)

  private def openNegBlock[_: P] = P("{{^" ~/ tag.! ~ "}}\n")
  private def openBlock[_: P] = P("{{#" ~/ tag.rep ~ "}}").map(_.toList)
  private def closeBlock[_: P](closeLabel: String) = P("{{/" ~/ closeLabel ~ "}}\n")
  private def tryCloseBlock[_: P] = P("{{/")

  private def variable[_: P] = P(unescapedVariable | escapedVariable)
  private def escapedVariable[_: P] = P("{{" ~/ tag.! ~ "}}").map(v => Variable(v, true))
  private def unescapedVariable[_: P] = P("{{{" ~/ tag.! ~ "}}}").map(v => Variable(v, false))

  private def partial[_: P] = P("{{>" ~/ tag.! ~ "}}").map(Partial(_, false))
  private def dynammicPartial[_: P] = P("{{>" ~ "(" ~ tag.! ~ ")" ~ "}}").map(Partial(_, true))

  private def tag[_: P]: P[String] = CharsWhileIn("""./_a-zA-Z0-9""").!
  private def strChars[_: P] = P(CharsWhile(_ != '{').!).map(Text(_))

  private def comment[_: P] = P("{{!" ~/ CharPred(_ != '}').rep ~ "}}\n").map(_ => Comment())

  private def block[_: P] = P(
    for {
      args <- openBlock
      block <- renderable.repX ~ closeBlock(args.head)
    } yield HelperOrSection(args.head, args.tail, block.toList)
  )

  def inverted[_: P] = P(
    for {
      label <- openNegBlock
      block <- renderable.rep ~ closeBlock(label)
    } yield Inverted(label, block.toList)
  )

  def compile(input: String): List[Renderable] = {
    parse(input, template(_)) match {
      case Parsed.Success(value, _) => value.toList
      case f @ Parsed.Failure(label, index, extra) =>
        println(f.trace())
        List.empty[Renderable]
      //        throw new Exception("Boom " + f.toString)
    }
  }

}

/*
  "slurp until" in {
    def slurpUntil[_: P](delimiter: String) = P( ((AnyChar ~ !delimiter).rep ~ AnyChar).! ~ delimiter )
    parse(input = "RCD*hello~RCD2*world~", slurpUntil("~")(_)) should matchPattern {
      case Parsed.Success("RCD*hello", 10) =>
    }
  }

    "higher order slurp" in {
    def slurpUntil[_: P, T](delimiter: => P[T]) : P[_] =
      P(
        (((AnyChar ~ !delimiter).rep ~ AnyChar).! ~ delimiter)
      .map( { case (fields, _) => fields }) )

    def delimiter[_: P] = P ( "~" )
    def slurper[_: P] = slurpUntil(delimiter)

    val in = "RCD*hello~"
    val inLen = in.length
    parse(in, slurper(_)) should matchPattern {
      case Parsed.Success("RCD*hello", `inLen`) =>
    }
  }
 */ 